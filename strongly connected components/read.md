## Входные данные

Первая строка содержит целые числа n, m, q, где 
n - количество гроздей винограда, 
m - количество ветвей, связывающих их, 
q - количество запросов

В следующих m строках содержатся пары чисел start,end (1≤start,end≤n), описывающие ветки (болезнь может распространяться лишь по направлению из грозди start в гроздь end).

## Выходные данные

В q строках вывести *YES*, если двигаясь по веткам в заданном направлении из грозди *a* в гроздь *b* можно вернуться в гроздь *a*, или *NO* в противном случае

# Решение
Найдем компоненты сильной связности (то есть максимальные подграфы, в которых существует путь между любыми двумя его вершинами в обоих направлениях)

Для этого создадим инвертированных граф исходного графа.

Если в оригинальном графе можно попасть из *А в В*, то в инвертированном наоборот, из *В в А*.Поиск в глубину по исходному графу (dfs1) и сохранение вершин в стэке, после того как вершина полностью обработана, гарантирует, что если существует путь из *А в В*, то *B* будет обработана раньше, чем *A*

При запуске dfs2 на инвертированном графе, следуя порядку, обратному времени завершения в оригинальном графе, мы гарантированно начинаем с вершин, которые были конечными. Это значит, что если мы можем достичь какой-то вершины из текущей вершины в инвертированном графе, то в оригинальном графе был путь от той вершины к текущей. Следовательно, вершины, посещённые в ходе одного запуска DFS в инвертированном графе, образуют компоненту сильной связности: все эти вершины
взаимодостижимы в оригинальном графе
